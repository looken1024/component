## 无状态session和有状态session和JWT

Session通常被用作Web应用程序中存储用户数据的机制。无状态和有状态Session是两种不同的方式来实现Session功能的方法。

#### 无状态(Unified)Session

无状态Session是一种不会持久保存用户会话状态的对象，每次请求结束都会重新创建一个Session对象，因此无状态Session的会话状态是临时的。无状态Session的优势在于降低系统的开销，避免了保存会话状态的复杂性和开销，同时也方便了开发人员的编写。

无状态Session指的是Session数据存储在客户端，而不是存储在服务器端。常见的实现方式是使用Cookie来存储Session ID，并将其他Session数据存储在Cookie中。无状态Session通常需要进行加密和签名，以确保数据的完整性和安全性。

#### 有状态Session

有状态Session指的是Session数据存储在服务器端，而不是存储在客户端。在有状态Session中，客户端和服务器之间的每个请求都需要包含Session ID，以便服务器可以在其本地存储中查找相应的Session数据。

有状态Session则是一种将用户会话状态保存在持久化资源中的对象，例如数据库中。每次请求时，会从持久化资源中获取最新的会话状态，并将会话状态与客户端的Session对象进行关联。有状态Session的优势在于可以提高系统的性能和可靠性，避免了由于会话状态丢失而导致的信息丢失的问题。

下面是无状态Session和有状态Session的一些区别：

存储位置：无状态Session数据存储在客户端，有状态Session数据存储在服务器端。

存储方式：无状态Session数据通常使用加密和签名等方式存储在Cookie中，有状态Session数据存储在服务器本地存储中。

安全性：

无状态Session数据需要进行加密和签名等操作来确保数据的安全性，因为数据存储在客户端。

有状态Session数据存储在服务器端，因此安全性更高。

可伸缩性：

无状态Session数据存储在客户端，因此能够轻松地扩展到多台服务器。

有状态Session数据存储在服务器端，因此需要更多的管理和配置来实现可伸缩性。

无状态Session的优点是性能好，扩展性好；缺点是安全性相对较低，容易受到攻击。有状态Session的优点是安全性高，便于管理和控制；缺点是性能稍差，扩展性不如无状态Session。

选择使用哪种Session方式，应该根据实际应用场景、安全需求和性能要求等因素综合考虑。

总的来说，无状态Session和有状态Session各有优缺点，开发者应根据具体的应用场景和需求选择合适的Session对象。

#### JWT

JWT（JSON Web Token）属于无状态Session的实现方式。JWT是一种开放标准（RFC 7519），是一种加密的字符串，定义了一种紧凑且自包含的方式，用于在各方之间作为JSON对象传输信息。JWT通常用于用户鉴权和授权等场景，用于在不同的系统之间传递身份验证和授权信息。

与传统的有状态Session实现方式不同，JWT不需要在服务器上维护会话状态或在客户端存储Session ID。相反，它们仅使用基于令牌的身份验证，这意味着每个请求都包含一个JWT令牌，而无需在服务器上存储任何信息。服务器可以使用JWT令牌来验证用户的身份并授予它们访问授权。

JWT通常被用于分布式系统或跨域应用的认证和授权场景，因为它不需要在多个系统之间共享Session ID，这使得JWT更具有可扩展性和灵活性。另外，JWT可以通过签名和加密等方式提高安全性，防止篡改和伪造。

需要注意的是，尽管JWT本身是无状态的，但仍然需要注意在实际使用中对于Token的安全性进行保护，比如防止Token泄露等问题。

JWT通常不属于有状态Session，因为JWT是一种独立的安全认证和授权机制，它不需要与有状态Session进行关联。相反，JWT通常是在请求发送方与接收方之间进行交换的，而不是在服务器端进行保存和更新的。

JWT的使用通常需要先进行身份验证，然后颁发JWT，接收方可以使用JWT来验证身份并授权访问相应的资源。因此，JWT可以被视为一种无状态Session，因为它不需要与有状态Session进行关联，而是在请求发送方和接收方之间进行交互。

在使用JWT的场景中，通常情况下不需要将JWT存储在Redis中。这是因为JWT是通过加密和签名等方式来保证其有效性和安全性的，而不需要在服务器端存储任何信息或状态。

在使用JWT进行身份验证时，服务器只需验证JWT的签名和有效期即可确认其有效性，无需查询任何数据库或缓存。JWT通常包含了所有必要的信息，如用户ID、角色、权限等，在进行请求时，客户端会在请求头或请求参数中携带JWT，服务器使用相同的密钥对JWT进行验证，即可确定该用户是否具有访问权限。

然而，在一些特殊的场景中，可能需要将JWT存储在Redis中。例如：

需要将JWT加入黑名单，防止已经失效的JWT被继续使用。

需要撤销某个用户的访问权限，需要强制让其失效。

需要将JWT进行缓存，以减少每次生成JWT的时间消耗。

总的来说，需要将JWT存储在Redis中的情况是比较少见的，通常情况下，JWT是无状态的，无需在服务器端存储任何信息或状态。


## HTTP无状态协议和session原理（access_token原理）

无状态协议是指协议对务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 Http协议不像建立了socket连接的两个终端，双方是可以互相通信的，http的客户端只能通过请求服务器来获取相关内容或文件信息

http协议这种特性有优点也有缺点，优点在于解放了服务器，每一次请求“点到为止”不会造成不必要连接占用，缺点在于每次请求会传输大量重复的内容信息。

客户端与服务器进行动态交互的Web应用程序出现之后，HTTP无状态的特性严重阻碍了这些应用程序的实现，毕竟交互是需要承前启后的，简单的购物车程序也要知道用户到底在之前选择了什么商品。于是，两种用于保持HTTP连接状态的技术就应运而生了，一个是Cookie，而另一个则是Session。HTTP本身是一个无状态的连接协议，为了支持客户端与服务器之间的交互，我们就需要通过不同的技术为交互存储状态，而这些不同的技术就是Cookie和Session了。

先来说说Cookie：

#### Cookie的产生

Cookie最早是网景公司的前雇员Lou Montulli在1993年3月的发明。

Cookie是由服务器端生成，发送给User-Agent（一般是web浏览器），浏览器会将Cookie的key/value保存到某个目录下的文本文件内，下次请求同一网站时就发送该Cookie给服务器（前提是浏览器设置为启用Cookie）。Cookie名称和值可以由服务器端开发自己定义，对于JSP而言也可以直接写入Sessionid，这样服务器可以知道该用户是否合法用户以及是否需要重新登录等。

#### Cookie用途

Cookies最典型的应用是判定注册用户是否已经登录网站，用户可能会得到提示，是否在下一次进入此网站时保留用户信息以便简化登录手续，这些都是Cookies的功用。另一个重要应用场合是“购物车”之类处理。用户可能会在一段时间内在同一家网站的不同页面中选择不同的商品，这些信息都会写入Cookies，以便在最后付款时提取信息。

#### Cookie生存周期

Cookie可以保持登录信息到用户下次与服务器的会话，换句话说，下次访问同一网站时，用户会发现不必输入用户名和密码就已经登录了（当然，不排除用户手工删除Cookie）。而还有一些Cookie在用户退出会话的时候就被删除了，这样可以有效保护个人隐私。

Cookie在生成时就会被指定一个Expire值，这就是Cookie的生存周期，在这个周期内Cookie有效，超出周期Cookie就会被清除。有些页面将Cookie的生存周期设置为“0”或负值，这样在关闭页面时，就马上清除Cookie，不会记录用户信息，更加安全。

Session:在计算机中，尤其是在网络应用中，称为“会话”。

#### Session简介

Session直接翻译成中文比较困难，一般都译成时域。在计算机专业术语中，Session是指一个终端用户与交互系统进行通信的时间间隔，通常指从注册进入系统到注销退出系统之间所经过的时间以及如果需要的话，可能还有一定的操作空间。

具体到Web中的Session指的就是用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间。因此从上述的定义中我们可以看到，Session实际上是一个特定的时间概念。

需要注意的是，一个Session的概念需要包括特定的客户端，特定的服务器端以及不中断的操作时间。A用户和C服务器建立连接时所处的Session同B用户和C服务器建立连接时所处的Session是两个不同的Session。

#### 何时产生Session，怎样产生Session？

当客户端访问服务器时，服务器根据需求设置Session，将会话信息保存在服务器上，同时将标示Session的SessionId传递给客户端浏览器，

浏览器将这个SessionId保存在内存中，我们称之为无过期时间的Cookie。浏览器关闭后，这个Cookie就会被清掉，它不会存在于用户的Cookie临时文件。

以后浏览器每次请求都会额外加上这个参数值，服务器会根据这个SessionId，就能取得客户端的数据信息。

如果客户端浏览器意外关闭，服务器保存的Session数据不是立即释放，此时数据还会存在，只要我们知道那个SessionId,就可以继续通过请求获得此Session的信息，因为此时后台的Session还存在，当然我们可以设置一个Session超时时间，一旦超过规定时间没有客户端请求时，服务器就会清除对应SessionId的Session信息。

综上所述我们可以理解Session的建立流程是：

当用浏览器登录到某网站服务器时，先找对应的Cookie文件，当首次访问是当然没有Cookie文件，所以在请求头部中没有Cookie的内容，即在请求头部中没有类似Cookie: JSESSIONID=XXXXXXXXXXXXXXX的内容，这时当请求到达服务器后，服务器看请求头中没有JSESSIONID值，于是生成一个Session对象，并由某种算法产生一个值赋给这个Session的id,并将SessionId,和Session对象放入HashMap中，然后将这个SessionId发回以客户端，即在响应的头部有一行：Set-Cookie:JSESSIONID=XXXXXXXXXXXXXX，浏览器解析后会将在JSESSIONID和值记录到Cookie中。

当用浏览器再次请求此网站的另一页面时，浏览器检查看有没有Cookie，这时有Cookie（前提是Cookie没有过期），会自动的把Cookie的内容附加到请求头中，即在请求头附加了一行：Cookie: JSESSIONID=XXXXXXXXXXXXXXXXXXXXXXX，服务器接收到请求后会根据JSESSIONID的值知道SessionId的值，在tomcat中两个值是一样的，然后你可根据这个SessionId找到对应的Session，可由Session中登录后设定的某些值是否为空，来判断此用户是否登录。

当用户安全登出后（调用session.invalidate()），服务器会将Session销毁，并生成一个新的JSESSIONID发回用客户端，浏览器接收响应后，会将Cookie中的JSESSIONID换成新值，当用户再次访问此服务器时，会在请求中自动的加入新的JSESSIONID的值发到服务器，这时服务器根据JSESSIONID找不对应的Session了，因此就可知道是一次新的会话，服务器会生成一个Session对象，并将客户端发过来的JSESSION的值赋给这个Session的id。

如果客户端禁用了Cookie那么服务器可就无法将session内容与客户端对应上了。

Session以tomcat为例默认是保存在内存中的，但是我们可以通过配置将Session持久化，保存在硬盘文件中。


